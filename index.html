<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Fluent Command Line Parser : A simple, strongly typed .NET C# command line parser library using a fluent easy to use interface">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Fluent Command Line Parser</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/fclp/fluent-command-line-parser">View on GitHub</a>

          <h1 id="project_title">Fluent Command Line Parser</h1>
          <h2 id="project_tagline">A simple, strongly typed .NET C# command line parser library using a fluent easy to use interface</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/fclp/fluent-command-line-parser/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/fclp/fluent-command-line-parser/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>A simple, strongly typed .NET C# command line parser library using a fluent easy to use interface.</p>

<h3>
<a id="download" class="anchor" href="#download" aria-hidden="true"><span class="octicon octicon-link"></span></a>Download</h3>

<p>See what's new in <a href="https://github.com/fclp/fluent-command-line-parser/wiki/Roadmap">v1.4</a>.</p>

<p>You can download the latest release from <a href="http://teamcity.codebetter.com/project.html?projectId=project314">CodeBetter's TeamCity server</a></p>

<p>You can also install using <a href="http://nuget.org/packages/FluentCommandLineParser/">NuGet</a> via the command line</p>

<pre><code>cmd&gt; nuget install FluentCommandLineParser
</code></pre>

<p>Or use the Package Manager console in Visual Studio:</p>

<pre><code>PM&gt; Install-Package FluentCommandLineParser
</code></pre>

<h3>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h3>

<p>See <a href="https://github.com/fclp/fluent-command-line-parser/wiki/So,-how-does-FCLP-compare-to-other-parsers%3F">here</a> for a side-by-side syntax comparison between other command line parsers.</p>

<p>Commands such as <code>updaterecord.exe -r 10 -v="Mr. Smith" --silent</code> can be captured using</p>

<div class="highlight highlight-c#"><pre><span class="pl-s">static</span> <span class="pl-st">void</span> Main(<span class="pl-st">string</span>[] args)
{
  <span class="pl-k">var</span> p = <span class="pl-s">new</span> FluentCommandLineParser();

  p.Setup&lt;<span class="pl-st">int</span>&gt;(<span class="pl-s1"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>)
   .Callback(record =&gt; RecordID = record)
   .Required();

  p.Setup&lt;<span class="pl-st">string</span>&gt;(<span class="pl-s1"><span class="pl-pds">'</span>v<span class="pl-pds">'</span></span>)
   .Callback(<span class="pl-k">value</span> =&gt; NewValue = <span class="pl-k">value</span>)
   .Required();

  p.Setup&lt;<span class="pl-st">bool</span>&gt;(<span class="pl-s1"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>silent<span class="pl-pds">"</span></span>)
   .Callback(silent =&gt; InSilentMode = silent)
   .SetDefault(<span class="pl-c1">false</span>);

  p.Parse(args);
}</pre></div>

<h3>
<a id="parser-option-methods" class="anchor" href="#parser-option-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parser Option Methods</h3>

<p><code>.Setup&lt;int&gt;('r')</code> Setup an option using a short name, </p>

<p><code>.Setup&lt;int&gt;('r', "record")</code> or short and long name.</p>

<p><code>.Required()</code> Indicate the option is required and an error should be raised if it is not provided.</p>

<p><code>.Callback(val =&gt; Value = val)</code> Provide a delegate to call after the option has been parsed</p>

<p><code>.SetDefault(int.MaxValue)</code> Define a default value if the option was not specified in the args</p>

<p><code>.WithDescription("Execute operation in silent mode without feedback")</code> Specify a help description for the option</p>

<h3>
<a id="parsing-using-the-generic-fluent-command-line-parser" class="anchor" href="#parsing-using-the-generic-fluent-command-line-parser" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parsing Using the Generic Fluent Command Line Parser</h3>

<p>Instead of assigning parsed values to variables you can use the generic Fluent Command Line Parser to automatically create a defined object type and setup individual Options for each strongly-typed property. Because the generic parser is simply a wrapper around the standard fluent parser you can still use the Fluent Command Line Parser Api to define the behaviour for each Option.</p>

<p>The generic Fluent Command Line Parser can build a type and populate the properties with parsed values such as in the following example: </p>

<div class="highlight highlight-c#"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">ApplicationArguments</span>
{
   <span class="pl-s">public</span> <span class="pl-st">int</span> <span class="pl-en">RecordId</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
   <span class="pl-s">public</span> <span class="pl-st">bool</span> <span class="pl-en">Silent</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
   <span class="pl-s">public</span> <span class="pl-st">string</span> <span class="pl-en">NewValue</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}

<span class="pl-s">static</span> <span class="pl-st">void</span> Main(<span class="pl-st">string</span>[] args)
{
   <span class="pl-c">// create a generic parser for the ApplicationArguments type</span>
   <span class="pl-k">var</span> p = <span class="pl-s">new</span> FluentCommandLineParser&lt;ApplicationArguments&gt;();

   <span class="pl-c">// specify which property the value will be assigned too.</span>
   p.Setup(arg =&gt; arg.RecordId)
    .As(<span class="pl-s1"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>record<span class="pl-pds">"</span></span>) <span class="pl-c">// define the short and long option name</span>
    .Required(); <span class="pl-c">// using the standard fluent Api to declare this Option as required.</span>

   p.Setup(arg =&gt; arg.NewValue)
    .As(<span class="pl-s1"><span class="pl-pds">'</span>v<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span>)
    .Required();

   p.Setup(arg =&gt; arg.Silent)
    .As(<span class="pl-s1"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>silent<span class="pl-pds">"</span></span>)
    .SetDefault(<span class="pl-c1">false</span>); <span class="pl-c">// use the standard fluent Api to define a default value if non is specified in the arguments</span>

   <span class="pl-k">var</span> result = p.Parse(args);

   <span class="pl-k">if</span>(result.HasErrors == <span class="pl-c1">false</span>)
   {
      <span class="pl-c">// use the instantiated ApplicationArguments object from the Object property on the parser.</span>
      application.Run(p.Object);
   }
}</pre></div>

<h3>
<a id="parsing-to-collections" class="anchor" href="#parsing-to-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parsing To Collections</h3>

<p>Many arguments can be collected as part of a list. Types supported are <code>string</code>, <code>int</code>, <code>double</code>, <code>bool</code> and <code>Enum</code></p>

<p>For example arguments such as</p>

<p><code>--filenames C:\file1.txt C:\file2.txt "C:\other file.txt"</code></p>

<p>can be automatically parsed to a <code>List&lt;string&gt;</code> using</p>

<div class="highlight highlight-c#"><pre><span class="pl-s">static</span> <span class="pl-st">void</span> Main(<span class="pl-st">string</span>[] args)
{
   <span class="pl-k">var</span> p = <span class="pl-s">new</span> FluentCommandLineParser();

   <span class="pl-k">var</span> filenames = <span class="pl-s">new</span> List&lt;<span class="pl-st">string</span>&gt;();

   p.Setup&lt;List&lt;<span class="pl-st">string</span>&gt;&gt;(<span class="pl-s1"><span class="pl-pds">'</span>f<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>filenames<span class="pl-pds">"</span></span>)
    .Callback(items =&gt; filenames = items);

   p.Parse(args);

   Console.WriteLine(<span class="pl-s1"><span class="pl-pds">"</span>Input file names:<span class="pl-pds">"</span></span>);

   <span class="pl-k">foreach</span> (<span class="pl-k">var</span> filename <span class="pl-k">in</span> filenames)
   {
      Console.WriteLine(filename);
   }
}</pre></div>

<p>output:</p>

<pre><code>Input file names
C:\file1.txt
C:\file2.txt
C:\other file.txt
</code></pre>

<h3>
<a id="enum-support" class="anchor" href="#enum-support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enum support</h3>

<p>Since v1.2.3 enum types are now supported. </p>

<div class="highlight highlight-c#"><pre>[Flags]
<span class="pl-s">enum</span> <span class="pl-en">Direction</span>
{
    North = <span class="pl-c1">1</span>,
    East = <span class="pl-c1">2</span>,
    South = <span class="pl-c1">4</span>,
    West = <span class="pl-c1">8</span>,
}</pre></div>

<div class="highlight highlight-c#"><pre>p.Setup&lt;Direction&gt;(<span class="pl-s1"><span class="pl-pds">"</span>direction<span class="pl-pds">"</span></span>)
 .Callback(d =&gt; direction = d);</pre></div>

<p>To specify 'East' direction either the text can be provided or the enum integer.</p>

<div class="highlight highlight-c#"><pre>dosomething.exe --direction East
dosomething.exe --direction <span class="pl-c1">2</span></pre></div>

<p>You can also collect multiple Enum values into a List</p>

<div class="highlight highlight-c#"><pre>List&lt;Direction&gt; direction;

p.Setup&lt;List&lt;Direction&gt;&gt;(<span class="pl-s1"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>direction<span class="pl-pds">"</span></span>)
 .Callback(d =&gt; direction = d);</pre></div>

<p>For example, specifiying 'South' and 'East' values</p>

<pre><code>dosomething.exe --direction South East
dosomething.exe --direction 4 2
</code></pre>

<p>Since v1.4 Enum Flags are also supported</p>

<div class="highlight highlight-c#"><pre>Direction direction;

p.Setup&lt;Direction&gt;(<span class="pl-s1"><span class="pl-pds">"</span>direction<span class="pl-pds">"</span></span>)
 .Callback(d =&gt; direction = d);

p.Parse(args);

Assert.IsFalse(direction.HasFlag(Direction.North));
Assert.IsTrue(direction.HasFlag(Direction.East));
Assert.IsTrue(direction.HasFlag(Direction.South));
Assert.IsFalse(direction.HasFlag(Direction.West));</pre></div>

<p>And the generic FluentCommandLineParser (previously known as FluentCommandLineBuilder) also supports enums.</p>

<div class="highlight highlight-c#"><pre><span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">Args</span>
{
   <span class="pl-s">public</span> Direction <span class="pl-en">Direction</span> { <span class="pl-k">get</span>;<span class="pl-k">set</span>; }
   <span class="pl-s">public</span> List&lt;Direction&gt; <span class="pl-en">Directions</span> { <span class="pl-k">get</span>;<span class="pl-k">set</span>; }
}</pre></div>

<div class="highlight highlight-c#"><pre><span class="pl-k">var</span> p = <span class="pl-s">new</span> FluentCommandLineParser&lt;Args&gt;();

p.Setup(args =&gt; args.Direction)
 .As(<span class="pl-s1"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>direction<span class="pl-pds">"</span></span>);

p.Setup(args =&gt; args.Directions)
 .As(<span class="pl-s1"><span class="pl-pds">"</span>directions<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="supported-syntax" class="anchor" href="#supported-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported Syntax</h3>

<p><code>[-|--|/][switch_name][=|:| ][value]</code></p>

<p>Supports boolean names</p>

<pre><code>example.exe -s  // enable
example.exe -s- // disabled
example.exe -s+ // enable
</code></pre>

<p>Supports combined (grouped) options</p>

<pre><code>example.exe -xyz  // enable option x, y and z
example.exe -xyz- // disable option x, y and z
example.exe -xyz+ // enable option x, y and z
</code></pre>

<h3>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span class="octicon octicon-link"></span></a>Development</h3>

<p>Fclp is in the early stages of development. Please feel free to provide any feedback on feature support or the Api itself.</p>

<p>If you would like to contribute, you may do so to the <a href="https://github.com/fclp/fluent-command-line-parser/tree/develop">develop branch</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Fluent Command Line Parser maintained by <a href="https://github.com/fclp">fclp</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-38952191-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
