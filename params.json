{"name":"Fluent Command Line Parser","tagline":"A simple, strongly typed .NET C# command line parser library using a fluent easy to use interface","body":"### Download\r\n\r\nSee what's new in [v1.2](https://github.com/fclp/fluent-command-line-parser/wiki/Roadmap).\r\n\r\nYou can download the latest release from [CodeBetter's TeamCity server](http://teamcity.codebetter.com/project.html?projectId=project314)\r\n\r\nYou can also install using [NuGet](http://nuget.org/packages/FluentCommandLineParser/)\r\n```\r\nPM> Install-Package FluentCommandLineParser\r\n```\r\n### Usage\r\n\r\nSee [here for a side-by-side syntax comparison](https://github.com/fclp/fluent-command-line-parser/wiki/So,-how-does-FCLP-compare-to-other-parsers%3F) between other command line parsers.\r\n\r\nCommands such as `updaterecord.exe -r 10 -v=\"Mr. Smith\" --silent` can be captured using\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n  var p = new FluentCommandLineParser();\r\n\r\n  p.Setup<int>('r')\r\n   .Callback(record => RecordID = record)\r\n   .Required();\r\n\r\n  p.Setup<string>('v')\r\n   .Callback(value => NewValue = value)\r\n   .Required();\r\n\r\n  p.Setup<bool>('s', \"silent\")\r\n   .Callback(silent => InSilentMode = silent)\r\n   .SetDefault(false);\r\n\r\n  p.Parse(args);\r\n}\r\n```\r\n### Parser Option Methods\r\n\r\n`.Setup<int>('r')` Setup an option using a short name, \r\n\r\n`.Setup<int>('r', \"record\")` or short and long name.\r\n\r\n`.Required()` Indicate the option is required and an error should be raised if it is not provided.\r\n\r\n`.Callback(val => Value = val)` Provide a delegate to call after the option has been parsed\r\n\r\n`.SetDefault(int.MaxValue)` Define a default value if the option was not specified in the args\r\n\r\n`.WithDescription(\"Execute operation in silent mode without feedback\")` Specify a help description for the option\r\n\r\n### Parsing Using Fluent Command Line Builder\r\n\r\nInstead of assigning parsed values to variables you can use the Fluent Command Line Builder to automatically create a defined object type and setup individual Options for each strongly-typed property. Because the builder is simply a wrapper around the parser you can still use the Fluent Command Line Parser Api to define the behaviour for each Option.\r\n\r\nThe Fluent Command Line Builder can build a type and populate the properties with parsed values such as in the following example: \r\n```\r\npublic class ApplicationArguments\r\n{\r\n   public int RecordId { get; set; }\r\n   public bool Silent { get; set; }\r\n   public string NewValue { get; set; }\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n   // create a builder for the ApplicationArguments type\r\n   var b = new FluentCommandLineBuilder<ApplicationArguments>();\r\n\r\n   // specify which property the value will be assigned too.\r\n   b.Setup(arg => arg.RecordId)\r\n    .As('r', \"record\") // define the short and long option name\r\n    .Required(); // using the standard fluent Api to declare this Option as required.\r\n\r\n   b.Setup(arg => arg.NewValue)\r\n    .As('v', \"value\")\r\n    .Required();\r\n\r\n   b.Setup(arg => arg.Silent)\r\n    .As('s', \"silent\")\r\n    .SetDefault(false); // use the standard fluent Api to define a default value if non is specified in the arguments\r\n\r\n   var result = b.Parse(args);\r\n\r\n   if(result.HasErrors == false)\r\n   {\r\n      // use the instantiated ApplicationArguments object from the Object property on the builder.\r\n      application.Run(b.Object);\r\n   }\r\n}\r\n```\r\n\r\n### Parsing To Collections\r\n\r\nMany arguments can be collected as part of a list. Types supported are `string`, `int`, `double` and `bool`\r\n\r\nFor example arguments such as\r\n\r\n`--filenames C:\\file1.txt C:\\file2.txt \"C:\\other file.txt\"`\r\n\r\ncan be automatically parsed to a `List<string>` using\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n   var p = new FluentCommandLineParser();\r\n\r\n   var filenames = new List<string>();\r\n\r\n   p.Setup<List<string>>('f', \"filenames\")\r\n    .Callback(items => filenames = items);\r\n\r\n   p.Parse(args);\r\n\r\n   Console.WriteLine(\"Input file names:\");\r\n\r\n   foreach (var filename in filenames)\r\n   {\r\n      Console.WriteLine(filename);\r\n   }\r\n}\r\n```\r\noutput:\r\n```\r\nInput file names\r\nC:\\file1.txt\r\nC:\\file2.txt\r\nC:\\other file.txt\r\n```\r\n### Supported Syntax\r\n`[-|--|/][switch_name][=|:| ][value]`\r\n\r\nSupports boolean names\r\n```\r\nexample.exe -s  // enable\r\nexample.exe -s- // disabled\r\nexample.exe -s+ // enable\r\n```\r\nSupports combined (grouped) options\r\n```\r\nexample.exe -xyz  // enable option x, y and z\r\nexample.exe -xyz- // disable option x, y and z\r\nexample.exe -xyz+ // enable option x, y and z\r\n```\r\n### Development\r\nFclp is in the early stages of development. Please feel free to provide any feedback on feature support or the Api itself.\r\n\r\nIf you would like to contribute, you may do so to the [develop branch](https://github.com/fclp/fluent-command-line-parser/tree/develop).","google":"UA-38952191-1","note":"Don't delete this file! It's used internally to help with page regeneration."}