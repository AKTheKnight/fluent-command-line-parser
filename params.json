{"name":"Fluent Command Line Parser","tagline":"A simple, strongly typed .NET C# command line parser library using a fluent easy to use interface","body":"Fluent Command Line Parser\r\n==========================\r\nA simple, strongly typed .NET C# command line parser library using a fluent easy to use interface.\r\n### Download\r\n\r\nSee what's new in [v1.3](https://github.com/fclp/fluent-command-line-parser/wiki/Roadmap).\r\n\r\nYou can download the latest release from [CodeBetter's TeamCity server](http://teamcity.codebetter.com/project.html?projectId=project314)\r\n\r\nYou can also install using [NuGet](http://nuget.org/packages/FluentCommandLineParser/)\r\n```\r\nPM> Install-Package FluentCommandLineParser\r\n```\r\n### Usage\r\nSee [here](https://github.com/fclp/fluent-command-line-parser/wiki/So,-how-does-FCLP-compare-to-other-parsers%3F) for a side-by-side syntax comparison between other command line parsers.\r\n\r\nCommands such as `updaterecord.exe -r 10 -v=\"Mr. Smith\" --silent` can be captured using\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n  var p = new FluentCommandLineParser();\r\n\r\n  p.Setup<int>('r')\r\n   .Callback(record => RecordID = record)\r\n   .Required();\r\n\r\n  p.Setup<string>('v')\r\n   .Callback(value => NewValue = value)\r\n   .Required();\r\n\r\n  p.Setup<bool>('s', \"silent\")\r\n   .Callback(silent => InSilentMode = silent)\r\n   .SetDefault(false);\r\n\r\n  p.Parse(args);\r\n}\r\n```\r\n### Parser Option Methods\r\n\r\n`.Setup<int>('r')` Setup an option using a short name, \r\n\r\n`.Setup<int>('r', \"record\")` or short and long name.\r\n\r\n`.Required()` Indicate the option is required and an error should be raised if it is not provided.\r\n\r\n`.Callback(val => Value = val)` Provide a delegate to call after the option has been parsed\r\n\r\n`.SetDefault(int.MaxValue)` Define a default value if the option was not specified in the args\r\n\r\n`.WithDescription(\"Execute operation in silent mode without feedback\")` Specify a help description for the option\r\n\r\n### Parsing Using the Generic Fluent Command Line Parser\r\n\r\nInstead of assigning parsed values to variables you can use the generic Fluent Command Line Parser to automatically create a defined object type and setup individual Options for each strongly-typed property. Because the generic parser is simply a wrapper around the standard fluent parser you can still use the Fluent Command Line Parser Api to define the behaviour for each Option.\r\n\r\nThe generic Fluent Command Line Parser can build a type and populate the properties with parsed values such as in the following example: \r\n```\r\npublic class ApplicationArguments\r\n{\r\n   public int RecordId { get; set; }\r\n   public bool Silent { get; set; }\r\n   public string NewValue { get; set; }\r\n}\r\n\r\nstatic void Main(string[] args)\r\n{\r\n   // create a generic parser for the ApplicationArguments type\r\n   var p = new FluentCommandLineParser<ApplicationArguments>();\r\n\r\n   // specify which property the value will be assigned too.\r\n   p.Setup(arg => arg.RecordId)\r\n    .As('r', \"record\") // define the short and long option name\r\n    .Required(); // using the standard fluent Api to declare this Option as required.\r\n\r\n   p.Setup(arg => arg.NewValue)\r\n    .As('v', \"value\")\r\n    .Required();\r\n\r\n   p.Setup(arg => arg.Silent)\r\n    .As('s', \"silent\")\r\n    .SetDefault(false); // use the standard fluent Api to define a default value if non is specified in the arguments\r\n\r\n   var result = p.Parse(args);\r\n\r\n   if(result.HasErrors == false)\r\n   {\r\n      // use the instantiated ApplicationArguments object from the Object property on the parser.\r\n      application.Run(p.Object);\r\n   }\r\n}\r\n```\r\n\r\n### Parsing To Collections\r\n\r\nMany arguments can be collected as part of a list. Types supported are `string`, `int`, `double` and `bool`\r\n\r\nFor example arguments such as\r\n\r\n`--filenames C:\\file1.txt C:\\file2.txt \"C:\\other file.txt\"`\r\n\r\ncan be automatically parsed to a `List<string>` using\r\n```\r\nstatic void Main(string[] args)\r\n{\r\n   var p = new FluentCommandLineParser();\r\n\r\n   var filenames = new List<string>();\r\n\r\n   p.Setup<List<string>>('f', \"filenames\")\r\n    .Callback(items => filenames = items);\r\n\r\n   p.Parse(args);\r\n\r\n   Console.WriteLine(\"Input file names:\");\r\n\r\n   foreach (var filename in filenames)\r\n   {\r\n      Console.WriteLine(filename);\r\n   }\r\n}\r\n```\r\noutput:\r\n```\r\nInput file names\r\nC:\\file1.txt\r\nC:\\file2.txt\r\nC:\\other file.txt\r\n```\r\n### Enum support\r\nSince v1.2.3 enum types are now supported. \r\n```\r\npublic enum Direction\r\n{\r\n\tLeft = 0,\r\n\tRight = 1,\r\n\tUp = 3,\r\n\tDown = 4\r\n}\r\n```\r\n```\r\np.Setup<Direction>('d', \"direction\")\r\n .Callback(d => direction = d);\r\n```\r\nTo specify 'Right' direction either the text can be provided or the enum integer.\r\n```\r\ndosomething.exe --direction Right\r\ndosomething.exe --direction 1\r\n```\r\n\r\nYou can also collect multiple Enum values into a List<TEnum>\r\n```\r\nList<Direction> direction;\r\n\r\np.Setup<List<Direction>>('d', \"direction\")\r\n .Callback(d => direction = d);\r\n```\r\nFor example, specifiying 'Right' and 'Up' values\r\n```\r\ndosomething.exe --direction Right Up\r\ndosomething.exe --direction 1 3\r\n```\r\nAnd the generic FluentCommandLineParser<T> (previously known as FluentCommandLineBuilder) also supports enums.\r\n\r\n```\r\npublic class Args\r\n{\r\n   public Direction Direction { get;set; }\r\n   public List<Direction> Directions { get;set; }\r\n}\r\n```\r\n```\r\nvar p = new FluentCommandLineParser<Args>();\r\n\r\np.Setup(args => args.Direction)\r\n .As('d', \"direction\");\r\n\r\np.Setup(args => args.Directions)\r\n .As(\"directions\");\r\n```\r\n### Supported Syntax\r\n`[-|--|/][switch_name][=|:| ][value]`\r\n\r\nSupports boolean names\r\n```\r\nexample.exe -s  // enable\r\nexample.exe -s- // disabled\r\nexample.exe -s+ // enable\r\n```\r\nSupports combined (grouped) options\r\n```\r\nexample.exe -xyz  // enable option x, y and z\r\nexample.exe -xyz- // disable option x, y and z\r\nexample.exe -xyz+ // enable option x, y and z\r\n```\r\n### Development\r\nFclp is in the early stages of development. Please feel free to provide any feedback on feature support or the Api itself.\r\n\r\nIf you would like to contribute, you may do so to the [develop branch](https://github.com/fclp/fluent-command-line-parser/tree/develop).","google":"UA-38952191-1","note":"Don't delete this file! It's used internally to help with page regeneration."}